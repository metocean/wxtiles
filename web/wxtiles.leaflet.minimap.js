// Generated by CoffeeScript 1.8.0
var _cloneLayer;

_cloneLayer = function(layer) {
  var layergroup, options, result;
  options = layer.options;
  if (layer instanceof L.WXTileLayer) {
    result = L.wxTileLayer(layer._config, options);
    result.setField(layer._field);
    result.setKey(layer._key);
    return result;
  }
  if (layer instanceof L.TileLayer) {
    return L.tileLayer(layer._url, options);
  }
  if (layer instanceof L.ImageOverlay) {
    return L.imageOverlay(layer._url, layer._bounds, options);
  }
  if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
    return L.polygon(layer.getLatLngs(), options);
  }
  if (layer instanceof L.Marker) {
    return L.marker(layer.getLatLng(), options);
  }
  if (layer instanceof L.circleMarker) {
    return L.circleMarker(layer.getLatLng(), options);
  }
  if (layer instanceof L.Polyline) {
    return L.polyline(layer.getLatLngs(), options);
  }
  if (layer instanceof L.MultiPolyline) {
    return L.polyline(layer.getLatLngs(), options);
  }
  if (layer instanceof L.MultiPolygon) {
    return L.MultiPolygon(layer.getLatLngs(), options);
  }
  if (layer instanceof L.Circle) {
    return L.circle(layer.getLatLng(), layer.getRadius(), options);
  }
  if (layer instanceof L.GeoJSON) {
    return L.geoJson(layer.toGeoJSON(), options);
  }
  if (layer instanceof L.LayerGroup || layer instanceof L.FeatureGroup) {
    layergroup = L.layerGroup();
    layer.eachLayer(function(inner) {
      return layergroup.addLayer(_cloneLayer(inner));
    });
    return layergroup;
  }
};

L.Control.Layers.WXTilesMinimap = L.Control.extend({
  options: {
    collapsed: true,
    autoZIndex: true,
    position: 'topright',
    topPadding: 10,
    bottomPadding: 40,
    backgroundLayer: L.tileLayer('http://a{s}.acetate.geoiq.com/tiles/acetate-base/{z}/{x}/{y}.png', {
      attribution: '&copy;2012 Esri & Stamen, Data from OSM and Natural Earth',
      subdomains: '0123',
      minZoom: 2,
      maxZoom: 18
    })
  },
  initialize: function(layers, options) {
    var i, _results;
    L.setOptions(this, options);
    this._layers = {};
    this._lastZIndex = 0;
    this._handlingClick = false;
    _results = [];
    for (i in layers) {
      _results.push(this._addLayer(layers[i], i));
    }
    return _results;
  },
  onAdd: function(map) {
    this._initLayout();
    this._update();
    map.on('layeradd', this._onLayerChange, this).on('layerremove', this._onLayerChange, this);
    return this._container;
  },
  onRemove: function(map) {
    return map.off('layeradd', this._onLayerChange, this).off('layerremove', this._onLayerChange, this);
  },
  addLayer: function(layer, name) {
    this._addLayer(layer, name);
    this._update();
    return this;
  },
  removeLayer: function(layer) {
    var id;
    id = L.stamp(layer);
    delete this._layers[id];
    this._update();
    return this;
  },
  _addLayer: function(layer, name) {
    var id;
    id = L.stamp(layer);
    this._layers[id] = {
      layer: layer,
      name: name
    };
    if (this.options.autoZIndex && layer.setZIndex) {
      this._lastZIndex++;
      return layer.setZIndex(this._lastZIndex);
    }
  },
  _onLayerChange: function(e) {
    var obj, type;
    obj = this._layers[L.stamp(e.layer)];
    if (!obj) {
      return;
    }
    if (!this._handlingClick) {
      this._update();
    }
    type = (e.type === 'layeradd' ? 'overlayadd' : 'overlayremove');
    if (type) {
      return this._map.fire(type, obj);
    }
  },
  filter: function(string) {
    var i, layerLabel, layerLabels;
    string = string.trim();
    layerLabels = this._container.querySelectorAll('label');
    i = 0;
    while (i < layerLabels.length) {
      layerLabel = layerLabels[i];
      if (string !== '' && layerLabel._layerName.indexOf(string) === -1) {
        L.DomUtil.addClass(layerLabel, 'leaflet-minimap-hidden');
      } else {
        L.DomUtil.removeClass(layerLabel, 'leaflet-minimap-hidden');
      }
      i++;
    }
    return this._onListScroll();
  },
  isCollapsed: function() {
    return !L.DomUtil.hasClass(this._container, 'leaflet-control-layers-expanded');
  },
  _expand: function() {
    L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
    return this._onListScroll();
  },
  _collapse: function() {
    return this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
  },
  _initLayout: function() {
    var className, container, form, link;
    className = 'leaflet-control-layers';
    container = this._container = L.DomUtil.create('div', className);
    container.setAttribute('aria-haspopup', true);
    if (!L.Browser.touch) {
      L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
    } else {
      L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
    }
    form = this._form = L.DomUtil.create('form', className + '-list');
    if (this.options.collapsed) {
      if (!L.Browser.android) {
        L.DomEvent.on(container, 'mouseover', this._expand, this).on(container, 'mouseout', this._collapse, this);
      }
      link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
      link.href = '#';
      link.title = 'Layers';
      if (L.Browser.touch) {
        L.DomEvent.on(link, 'click', L.DomEvent.stop).on(link, 'click', this._expand, this);
      } else {
        L.DomEvent.on(link, 'focus', this._expand, this);
      }
      L.DomEvent.on(form, 'click', (function() {
        setTimeout(L.bind(this._onInputClick, this), 0);
      }), this);
      this._map.on('click', this._collapse, this);
    } else {
      this._expand();
    }
    this._layerList = L.DomUtil.create('div', className + '-layers', form);
    container.appendChild(form);
    L.DomUtil.addClass(this._container, 'leaflet-control-layers-minimap');
    return L.DomEvent.on(this._container, 'scroll', this._onListScroll, this);
  },
  _update: function() {
    var layer, _, _ref;
    if (this._container) {
      this._layerList.innerHTML = "";
      _ref = this._layers;
      for (_ in _ref) {
        layer = _ref[_];
        this._addItem(layer);
      }
    }
    this._map.on('resize', this._onResize, this);
    this._onResize();
    return this._map.whenReady(this._onListScroll, this);
  },
  _createRadioElement: function(name, checked) {
    var radioFragment, radioHtml;
    radioHtml = "<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"" + name + "\"";
    if (checked) {
      radioHtml += " checked=\"checked\"";
    }
    radioHtml += "/>";
    radioFragment = document.createElement('div');
    radioFragment.innerHTML = radioHtml;
    return radioFragment.firstChild;
  },
  _addItem: function(obj) {
    var checked, container, input, label, name, span;
    container = this._layerList;
    label = L.DomUtil.create('label', 'leaflet-minimap-container', container);
    label._layerName = obj.name;
    checked = this._map.hasLayer(obj.layer);
    this._createMinimap(L.DomUtil.create('div', 'leaflet-minimap', label), obj.layer);
    span = L.DomUtil.create('span', 'leaflet-minimap-label', label);
    input = this._createRadioElement('leaflet-control-layers-selector', checked);
    input.layerId = L.stamp(obj.layer);
    span.appendChild(input);
    L.DomEvent.on(label, 'click', this._onInputClick, this);
    name = L.DomUtil.create('span', '', span);
    return name.innerHTML = ' ' + obj.name;
  },
  _onResize: function() {
    var controlHeight, mapHeight;
    mapHeight = this._map.getContainer().clientHeight;
    controlHeight = this._container.clientHeight;
    if (controlHeight > mapHeight - this.options.bottomPadding) {
      this._container.style.overflowY = 'scroll';
    }
    return this._container.style.maxHeight = (mapHeight - this.options.bottomPadding - this.options.topPadding) + 'px';
  },
  _onListScroll: function() {
    var container, first, i, last, layer, listHeight, map, minimap, minimapHeight, minimaps, scrollTop, _results;
    minimaps = document.querySelectorAll("label[class='leaflet-minimap-container']");
    if (minimaps.length === 0) {
      return;
    }
    first = void 0;
    last = void 0;
    if (this.isCollapsed()) {
      first = last = -1;
    } else {
      minimapHeight = minimaps.item(0).clientHeight;
      container = this._container;
      listHeight = container.clientHeight;
      scrollTop = container.scrollTop;
      first = Math.floor(scrollTop / minimapHeight);
      last = Math.ceil((scrollTop + listHeight) / minimapHeight);
    }
    i = 0;
    _results = [];
    while (i < minimaps.length) {
      minimap = minimaps[i].childNodes.item(0);
      map = minimap._miniMap;
      layer = map._layer;
      if (!layer) {
        continue;
      }
      if (i >= first && i <= last) {
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        map.invalidateSize();
      } else {
        if (map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      }
      _results.push(++i);
    }
    return _results;
  },
  _onInputClick: function() {
    var i, input, inputs, inputsLen, obj;
    i = void 0;
    input = void 0;
    obj = void 0;
    inputs = this._form.getElementsByTagName('input');
    inputsLen = inputs.length;
    this._handlingClick = true;
    i = 0;
    while (i < inputsLen) {
      input = inputs[i];
      obj = this._layers[input.layerId];
      if (input.checked && !this._map.hasLayer(obj.layer)) {
        this._map.addLayer(obj.layer);
      } else {
        if (!input.checked && this._map.hasLayer(obj.layer)) {
          this._map.removeLayer(obj.layer);
        }
      }
      i++;
    }
    this._handlingClick = false;
    return this._refocusOnMap();
  },
  _createMinimap: function(mapContainer, originalLayer) {
    var map, minimap;
    minimap = mapContainer._miniMap = L.map(mapContainer, {
      attributionControl: false,
      zoomControl: false
    });
    minimap.dragging.disable();
    minimap.touchZoom.disable();
    minimap.doubleClickZoom.disable();
    minimap.scrollWheelZoom.disable();
    minimap._layer = L.layerGroup([_cloneLayer(this.options.backgroundLayer), _cloneLayer(originalLayer)]);
    map = this._map;
    return map.whenReady(function() {
      minimap.setView(map.getCenter(), map.getZoom());
      return map.sync(minimap);
    });
  }
});

L.control.layers.wxTilesMinimap = function(layers, options) {
  return new L.Control.Layers.WXTilesMinimap(layers, options);
};
