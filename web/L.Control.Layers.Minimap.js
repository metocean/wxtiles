// Generated by CoffeeScript 1.7.1
var _cloneLayer;

_cloneLayer = function(layer) {
  var layergroup, options, result;
  options = layer.options;
  if (layer instanceof L.WXTileLayer) {
    result = L.wxTileLayer(layer._config, options);
    result.setField(layer._field);
    result.setKey(layer._key);
    return result;
  }
  if (layer instanceof L.TileLayer) {
    return L.tileLayer(layer._url, options);
  }
  if (layer instanceof L.ImageOverlay) {
    return L.imageOverlay(layer._url, layer._bounds, options);
  }
  if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
    return L.polygon(layer.getLatLngs(), options);
  }
  if (layer instanceof L.Marker) {
    return L.marker(layer.getLatLng(), options);
  }
  if (layer instanceof L.circleMarker) {
    return L.circleMarker(layer.getLatLng(), options);
  }
  if (layer instanceof L.Polyline) {
    return L.polyline(layer.getLatLngs(), options);
  }
  if (layer instanceof L.MultiPolyline) {
    return L.polyline(layer.getLatLngs(), options);
  }
  if (layer instanceof L.MultiPolygon) {
    return L.MultiPolygon(layer.getLatLngs(), options);
  }
  if (layer instanceof L.Circle) {
    return L.circle(layer.getLatLng(), layer.getRadius(), options);
  }
  if (layer instanceof L.GeoJSON) {
    return L.geoJson(layer.toGeoJSON(), options);
  }
  if (layer instanceof L.LayerGroup || layer instanceof L.FeatureGroup) {
    layergroup = L.layerGroup();
    layer.eachLayer(function(inner) {
      return layergroup.addLayer(_cloneLayer(inner));
    });
    return layergroup;
  }
};

L.Control.Layers.Minimap = L.Control.Layers.extend({
  options: {
    position: 'topright',
    topPadding: 10,
    bottomPadding: 40,
    overlayBackgroundLayer: L.tileLayer('http://a{s}.acetate.geoiq.com/tiles/acetate-base/{z}/{x}/{y}.png', {
      attribution: '&copy;2012 Esri & Stamen, Data from OSM and Natural Earth',
      subdomains: '0123',
      minZoom: 2,
      maxZoom: 18
    })
  },
  filter: function(string) {
    var i, layerLabel, layerLabels;
    string = string.trim();
    layerLabels = this._container.querySelectorAll('label');
    i = 0;
    while (i < layerLabels.length) {
      layerLabel = layerLabels[i];
      if (string !== '' && layerLabel._layerName.indexOf(string) === -1) {
        L.DomUtil.addClass(layerLabel, 'leaflet-minimap-hidden');
      } else {
        L.DomUtil.removeClass(layerLabel, 'leaflet-minimap-hidden');
      }
      i++;
    }
    return this._onListScroll();
  },
  isCollapsed: function() {
    return !L.DomUtil.hasClass(this._container, 'leaflet-control-layers-expanded');
  },
  _expand: function() {
    L.Control.Layers.prototype._expand.call(this);
    return this._onListScroll();
  },
  _initLayout: function() {
    L.Control.Layers.prototype._initLayout.call(this);
    L.DomUtil.addClass(this._container, 'leaflet-control-layers-minimap');
    return L.DomEvent.on(this._container, 'scroll', this._onListScroll, this);
  },
  _update: function() {
    L.Control.Layers.prototype._update.call(this);
    this._map.on('resize', this._onResize, this);
    this._onResize();
    return this._map.whenReady(this._onListScroll, this);
  },
  _addItem: function(obj) {
    var checked, container, input, label, name, span;
    container = obj.overlay ? this._overlaysList : this._baseLayersList;
    label = L.DomUtil.create('label', 'leaflet-minimap-container', container);
    label._layerName = obj.name;
    checked = this._map.hasLayer(obj.layer);
    this._createMinimap(L.DomUtil.create('div', 'leaflet-minimap', label), obj.layer, obj.overlay);
    span = L.DomUtil.create('span', 'leaflet-minimap-label', label);
    input = void 0;
    if (obj.overlay) {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.className = 'leaflet-control-layers-selector';
      input.defaultChecked = checked;
    } else {
      input = this._createRadioElement('leaflet-base-layers', checked);
    }
    input.layerId = L.stamp(obj.layer);
    span.appendChild(input);
    L.DomEvent.on(label, 'click', this._onInputClick, this);
    name = L.DomUtil.create('span', '', span);
    name.innerHTML = ' ' + obj.name;
    return label;
  },
  _onResize: function() {
    var controlHeight, mapHeight;
    mapHeight = this._map.getContainer().clientHeight;
    controlHeight = this._container.clientHeight;
    if (controlHeight > mapHeight - this.options.bottomPadding) {
      this._container.style.overflowY = 'scroll';
    }
    return this._container.style.maxHeight = (mapHeight - this.options.bottomPadding - this.options.topPadding) + 'px';
  },
  _onListScroll: function() {
    var container, first, i, last, layer, listHeight, map, minimap, minimapHeight, minimaps, scrollTop, _results;
    minimaps = document.querySelectorAll("label[class='leaflet-minimap-container']");
    if (minimaps.length === 0) {
      return;
    }
    first = void 0;
    last = void 0;
    if (this.isCollapsed()) {
      first = last = -1;
    } else {
      minimapHeight = minimaps.item(0).clientHeight;
      container = this._container;
      listHeight = container.clientHeight;
      scrollTop = container.scrollTop;
      first = Math.floor(scrollTop / minimapHeight);
      last = Math.ceil((scrollTop + listHeight) / minimapHeight);
    }
    i = 0;
    _results = [];
    while (i < minimaps.length) {
      minimap = minimaps[i].childNodes.item(0);
      map = minimap._miniMap;
      layer = map._layer;
      if (!layer) {
        continue;
      }
      if (i >= first && i <= last) {
        if (!map.hasLayer(layer)) {
          layer.addTo(map);
        }
        map.invalidateSize();
      } else {
        if (map.hasLayer(layer)) {
          map.removeLayer(layer);
        }
      }
      _results.push(++i);
    }
    return _results;
  },
  _createMinimap: function(mapContainer, originalLayer, isOverlay) {
    var map, minimap;
    minimap = mapContainer._miniMap = L.map(mapContainer, {
      attributionControl: false,
      zoomControl: false
    });
    minimap.dragging.disable();
    minimap.touchZoom.disable();
    minimap.doubleClickZoom.disable();
    minimap.scrollWheelZoom.disable();
    if (isOverlay) {
      minimap._layer = L.layerGroup([_cloneLayer(this.options.overlayBackgroundLayer), _cloneLayer(originalLayer)]);
    } else {
      minimap._layer = _cloneLayer(originalLayer);
    }
    map = this._map;
    return map.whenReady(function() {
      minimap.setView(map.getCenter(), map.getZoom());
      return map.sync(minimap);
    });
  }
});

L.control.layers.minimap = function(baseLayers, overlays, options) {
  return new L.Control.Layers.Minimap(baseLayers, overlays, options);
};
